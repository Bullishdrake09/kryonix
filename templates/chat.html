{% extends "base.html" %}

{% block title %}Kryonix Chat - {{ username }}{% endblock %}

{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

<style>
/* Search Bar Styles */
.search-container {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
}

.search-input {
    width: 100%;
    padding: 8px 12px;
    background: var(--darker);
    border: 1px solid var(--border);
    border-radius: 20px;
    color: var(--light);
    outline: none;
    font-size: 0.9rem;
}

.search-input:focus {
    border-color: var(--primary);
}

/* Create Group Button */
.create-group-btn {
    width: 100%;
    padding: 12px;
    margin: 8px 16px;
    width: calc(100% - 32px);
    background: var(--primary);
    color: var(--darker);
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
}

.create-group-btn:hover {
    background: var(--primary-dark);
}

/* Group Chat Indicator */
.group-indicator {
    background: var(--primary);
    color: var(--darker);
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: 600;
}

/* Media Preview Modal */
.media-preview-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}

.media-preview-modal.active {
    display: flex;
}

.media-preview-content {
    max-width: 90%;
    max-height: 90%;
    background: var(--darker);
    border-radius: 12px;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.media-preview-content img,
.media-preview-content video {
    max-width: 600px;
    max-height: 400px;
    border-radius: 8px;
    object-fit: contain;
}

.media-preview-actions {
    display: flex;
    gap: 12px;
    justify-content: center;
}

.media-preview-actions button {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.send-media-btn {
    background: var(--success);
    color: var(--darker);
}

.cancel-media-btn {
    background: var(--danger);
    color: white;
}

/* Group Modal */
.group-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1500;
    justify-content: center;
    align-items: center;
}

.group-modal.active {
    display: flex;
}

.group-modal-content {
    background: var(--darker);
    padding: 32px;
    border-radius: 16px;
    border: 2px solid var(--border);
    min-width: 400px;
    max-width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.group-modal-content h3 {
    color: var(--light);
    margin-bottom: 24px;
}

.group-form {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.group-form input[type="text"] {
    width: 100%;
    padding: 12px;
    background: var(--light-gray);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--light);
    outline: none;
}

.group-form input[type="text"]:focus {
    border-color: var(--primary);
}

.member-selection {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
}

.member-checkbox {
    display: flex;
    align-items: center;
    padding: 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.2s;
}

.member-checkbox:hover {
    background: var(--light-gray);
}

.member-checkbox input[type="checkbox"] {
    margin-right: 12px;
}

.member-checkbox label {
    cursor: pointer;
    color: var(--light);
}

.group-members-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.group-member-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    background: var(--light-gray);
    border-radius: 8px;
}

.member-info {
    display: flex;
    align-items: center;
    gap: 12px;
}

.member-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--primary);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: var(--darker);
    overflow: hidden;
}

.member-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.creator-badge {
    background: var(--primary);
    color: var(--darker);
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: 600;
}

.kick-btn {
    background: var(--danger);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: background 0.2s;
}

.kick-btn:hover {
    background: #e54d4d;
}

.group-actions {
    display: flex;
    gap: 12px;
    margin-top: 16px;
}

.group-actions button {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.create-group-submit {
    background: var(--primary);
    color: var(--darker);
}

.cancel-group-btn {
    background: var(--light-gray);
    color: var(--light);
}

.leave-group-btn {
    background: var(--danger);
    color: white;
}

.leave-group-btn:hover {
    background: #e54d4d;
}

/* Reply UI Styles */
.reply-preview {
    background: rgba(138, 43, 226, 0.15);
    border-left: 3px solid #8a2be2;
    padding: 8px 12px;
    margin: 8px 0;
    border-radius: 12px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 43, 226, 0.3);
}

.reply-preview-content {
    flex: 1;
}

.reply-preview-username {
    color: #8a2be2;
    font-size: 0.85em;
    font-weight: 700;
    margin-bottom: 2px;
    text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
}

.reply-preview-text {
    color: #adb5bd;
    font-size: 0.9em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 90%;
}

.reply-preview-close {
    background: none;
    border: none;
    color: #6c757d;
    cursor: pointer;
    font-size: 1.2em;
    padding: 0;
    margin-left: 8px;
    transition: all 0.3s ease;
}

.reply-preview-close:hover {
    color: #ff6b6b;
    transform: scale(1.1);
}

.message-reply-context {
    background: rgba(138, 43, 226, 0.1);
    border-left: 3px solid #8a2be2;
    padding: 6px 10px;
    margin-bottom: 6px;
    border-radius: 8px;
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid rgba(138, 43, 226, 0.2);
}

.message-reply-context:hover {
    background: rgba(138, 43, 226, 0.2);
    transform: translateX(3px);
    border-color: rgba(138, 43, 226, 0.4);
}

.message-reply-username {
    color: #8a2be2;
    font-weight: 700;
    margin-bottom: 2px;
    text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
}

.message-reply-text {
    color: #adb5bd;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.message.highlighted {
    animation: highlight-pulse 1s ease-in-out;
}

@keyframes highlight-pulse {
    0%, 100% {
        background: transparent;
    }
    50% {
        background: rgba(138, 43, 226, 0.3);
        box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
    }
}

.message-actions button.reply-btn {
    background: linear-gradient(45deg, rgba(138, 43, 226, 0.2), rgba(75, 0, 130, 0.2));
    color: #8a2be2;
    border: 1px solid rgba(138, 43, 226, 0.3);
    transition: all 0.3s ease;
}

.message-actions button.reply-btn:hover {
    background: linear-gradient(45deg, #8a2be2, #4b0082);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
}

/* Loading indicator */
.loading-messages {
    text-align: center;
    padding: 12px;
    color: var(--gray);
    font-style: italic;
}

@media (max-width: 768px) {
    .group-modal-content {
        min-width: auto;
        width: 90%;
        padding: 24px;
    }
}
</style>

<div class="mobile-header" id="mobile-header">
    <button class="menu-toggle" id="menu-toggle"><i class="fas fa-bars"></i></button>
    <h2 id="mobile-chat-title">Kryonix Chat</h2>
    <span style="visibility: hidden;"><i class="fas fa-bars"></i></span>
</div>

<div class="app-container">
    <div class="sidebar" id="sidebar">
        <button class="close-button" id="close-sidebar-button"><i class="fas fa-times"></i></button>
        <div class="user-info">
            <div class="avatar">
                {% if current_user.profile_picture %}
                <img src="{{ current_user.profile_picture }}" alt="{{ current_user.username }}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">
                {% else %}
                {{ current_user.username[0].upper() }}
                {% endif %}
            </div>
            <div class="username">{{ username }}</div>
        </div>
        
        <!-- Search Bar -->
        <div class="search-container">
            <input type="text" class="search-input" id="contact-search" placeholder="Search contacts...">
        </div>
        
        <nav>
            <a href="{{ url_for('chat') }}">Chats</a>
            <a href="{{ url_for('friends') }}">Friends</a>
            <a href="{{ url_for('settings') }}">Settings</a>
            {% if current_user.username == 'admin' %}
            <a href="{{ url_for('admin_page') }}">Admin Panel</a>
            {% endif %}
        </nav>

        <button class="create-group-btn" id="create-group-btn">
            <i class="fas fa-users"></i> Create Group
        </button>

        <div class="friends-list">
            <h3>Chats</h3>
            <ul id="friend-list-ul">
                {% if not friends_list and not group_chats %}
                <p class="initial-chat-message">Add friends to start chatting</p>
                {% endif %}
                
                {% for group in group_chats %}
                <li data-room-id="{{ group.id }}" data-room-type="group" data-room-name="{{ group.name }}">
                    <div class="friend-avatar" style="background: var(--primary);">
                        <i class="fas fa-users"></i>
                    </div>
                    <span>{{ group.name }} <span class="group-indicator">GROUP</span></span>
                </li>
                {% endfor %}
                
                {% for friend in friends_list %}
                <li data-friend-username="{{ friend }}" data-room-type="direct">
                    <div class="friend-avatar">
                        <span id="avatar-{{ friend }}">{{ friend[0].upper() }}</span>
                        <span class="status-indicator online" data-username="{{ friend }}"></span>
                    </div>
                    <span>{{ friend }}</span>
                </li>
                {% endfor %}
            </ul>
        </div>
        <a href="{{ url_for('logout') }}" class="logout-button">Logout</a>
    </div>

    <div class="chat-area">
        <div id="status-overlay">
            <p id="overlay-message"></p>
            <button onclick="hideOverlay()">OK</button>
        </div>

        <div class="chat-header">
            <h2 id="current-chat-header"></h2>
            <div class="header-links">
                <div class="call-icons" id="call-icons" style="display: none;">
                    <button class="call-icon-btn" id="audio-call-btn" title="Audio Call">
                        <i class="fas fa-phone"></i>
                    </button>
                    <button class="call-icon-btn" id="video-call-btn" title="Video Call">
                        <i class="fas fa-video"></i>
                    </button>
                </div>
                <a href="#" id="edit-group-btn" style="display: none;">Edit Group</a>
            </div>
        </div>
        
        <!-- Reply Preview Bar -->
        <div class="reply-preview" id="reply-preview" style="display: none;">
            <div class="reply-preview-content">
                <div class="reply-preview-username" id="reply-username"></div>
                <div class="reply-preview-text" id="reply-text"></div>
            </div>
            <button class="reply-preview-close" id="cancel-reply">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="chat-messages" id="chat-messages">
            {% if not friends_list and not group_chats %}
            <p class="initial-chat-message">Add friends to start chatting!</p>
            {% else %}
            <p class="initial-chat-message" id="select-chat-prompt">Select a friend or group from the sidebar to start chatting.</p>
            {% endif %}
        </div>
        
        <div class="chat-input-area">
            <input type="text" id="message-input" placeholder="Type a message...">
            <label for="file-input">
                <i class="fas fa-paperclip"></i>
            </label>
            <input type="file" id="file-input" accept="image/*,video/*">
            <button id="send-button"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>
</div>

<!-- Media Preview Modal -->
<div class="media-preview-modal" id="media-preview-modal">
    <div class="media-preview-content">
        <div id="media-preview-container"></div>
        <div class="media-preview-actions">
            <button class="send-media-btn" id="send-media-btn">
                <i class="fas fa-paper-plane"></i> Send
            </button>
            <button class="cancel-media-btn" id="cancel-media-btn">
                <i class="fas fa-times"></i> Cancel
            </button>
        </div>
    </div>
</div>

<!-- Create/Edit Group Modal -->
<div class="group-modal" id="group-modal">
    <div class="group-modal-content">
        <h3 id="group-modal-title"><i class="fas fa-users"></i> Create New Group</h3>
        
        <!-- Create Group Form -->
        <div class="group-form" id="create-group-form">
            <input type="text" id="group-name-input" placeholder="Group Name" maxlength="50">
            <div class="member-selection" id="member-selection">
                {% for friend in friends_list %}
                <div class="member-checkbox">
                    <input type="checkbox" id="member-{{ friend }}" value="{{ friend }}">
                    <label for="member-{{ friend }}">{{ friend }}</label>
                </div>
                {% endfor %}
            </div>
            <div class="group-actions">
                <button class="create-group-submit" id="create-group-submit">Create</button>
                <button class="cancel-group-btn" id="cancel-group-btn">Cancel</button>
            </div>
        </div>
        
        <!-- Edit Group Form -->
        <div class="group-form" id="edit-group-form" style="display: none;">
            <input type="text" id="edit-group-name-input" placeholder="Group Name" maxlength="50">
            <div class="group-members-list" id="group-members-list">
                <!-- Members will be dynamically added here -->
            </div>
            <div class="group-actions">
                <button class="create-group-submit" id="save-group-btn">Save Changes</button>
                <button class="leave-group-btn" id="leave-group-btn">Leave Group</button>
                <button class="cancel-group-btn" id="cancel-edit-group-btn">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- Video Call Modal -->
<div class="call-modal" id="call-modal">
    <div class="call-content">
        <div class="call-header">
            <h3 id="call-title">Video Call</h3>
            <span id="call-status" style="color: var(--gray);">Connecting...</span>
        </div>
        <button class="settings-call-btn" id="settings-call-btn" title="Settings">
            <i class="fas fa-cog"></i>
        </button>
        <button class="minimize-call-btn" id="minimize-call-btn" title="Minimize">
            <i class="fas fa-minus"></i>
        </button>
        <div class="video-container">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>
        </div>
        <div class="call-controls">
            <button class="call-button mute" id="mute-audio-btn" title="Mute Audio">
                <i class="fas fa-microphone"></i>
            </button>
            <button class="call-button mute" id="mute-video-btn" title="Turn Off Video">
                <i class="fas fa-video"></i>
            </button>
            <button class="call-button end" id="end-call-btn" title="End Call">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>
</div>

<!-- Device Settings Modal -->
<div class="device-settings-modal" id="device-settings-modal">
    <h3><i class="fas fa-cog"></i> Device Settings</h3>
    <div class="device-setting">
        <label for="microphone-select">Microphone</label>
        <select id="microphone-select">
            <option value="">Loading...</option>
        </select>
    </div>
    <div class="device-setting">
        <label for="camera-select">Camera</label>
        <select id="camera-select">
            <option value="">Loading...</option>
        </select>
    </div>
    <div class="device-settings-actions">
        <button class="save-settings-btn" id="save-settings-btn">Apply</button>
        <button class="cancel-settings-btn" id="cancel-settings-btn">Cancel</button>
    </div>
</div>

<!-- Incoming Call Modal -->
<div class="incoming-call-modal" id="incoming-call-modal">
    <h3><i class="fas fa-phone" style="color: var(--primary);"></i> Incoming Call</h3>
    <p id="caller-name">Someone is calling you...</p>
    <p id="call-type-text">Video Call</p>
    <div class="incoming-call-actions">
        <button class="answer-button" id="answer-call-btn">
            <i class="fas fa-phone"></i> Answer
        </button>
        <button class="reject-button" id="reject-call-btn">
            <i class="fas fa-phone-slash"></i> Reject
        </button>
    </div>
</div>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
    const socket = io();
    const username = "{{ username }}";
    let currentRoom = null;
    let currentRoomType = 'direct';
    let isLoadingHistory = false;
    let userStatus = 'offline';
    let typingTimeout = null;
    let connectedUsers = {};
    let replyingTo = null;
    let messageOffset = 0;
    let hasMoreMessages = true;
    let isLoadingMore = false;
    let pendingMediaFile = null;
    let userProfiles = {};
    let currentGroupInfo = null;
    
    // WebRTC variables
    let localStream = null;
    let remoteStream = null;
    let peerConnection = null;
    let currentCallType = null;
    let isCallActive = false;
    let incomingCallData = null;
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };
    
    // DOM Elements
    const sidebar = document.getElementById('sidebar');
    const menuToggle = document.getElementById('menu-toggle');
    const closeSidebarButton = document.getElementById('close-sidebar-button');
    const chatMessagesDiv = document.getElementById('chat-messages');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const currentChatHeader = document.getElementById('current-chat-header');
    const friendListUl = document.getElementById('friend-list-ul');
    const fileInput = document.getElementById('file-input');
    const statusOverlay = document.getElementById('status-overlay');
    const overlayMessage = document.getElementById('overlay-message');
    const selectChatPrompt = document.getElementById('select-chat-prompt');
    const contactSearch = document.getElementById('contact-search');
    const createGroupBtn = document.getElementById('create-group-btn');
    const groupModal = document.getElementById('group-modal');
    const groupModalTitle = document.getElementById('group-modal-title');
    const createGroupForm = document.getElementById('create-group-form');
    const editGroupForm = document.getElementById('edit-group-form');
    const cancelGroupBtn = document.getElementById('cancel-group-btn');
    const cancelEditGroupBtn = document.getElementById('cancel-edit-group-btn');
    const createGroupSubmit = document.getElementById('create-group-submit');
    const groupNameInput = document.getElementById('group-name-input');
    const editGroupNameInput = document.getElementById('edit-group-name-input');
    const saveGroupBtn = document.getElementById('save-group-btn');
    const leaveGroupBtn = document.getElementById('leave-group-btn');
    const groupMembersList = document.getElementById('group-members-list');
    const editGroupBtn = document.getElementById('edit-group-btn');
    const mediaPreviewModal = document.getElementById('media-preview-modal');
    const mediaPreviewContainer = document.getElementById('media-preview-container');
    const sendMediaBtn = document.getElementById('send-media-btn');
    const cancelMediaBtn = document.getElementById('cancel-media-btn');
    
    // Reply elements
    const replyPreview = document.getElementById('reply-preview');
    const replyUsername = document.getElementById('reply-username');
    const replyText = document.getElementById('reply-text');
    const cancelReplyBtn = document.getElementById('cancel-reply');
    
    // Call elements
    const callModal = document.getElementById('call-modal');
    const incomingCallModal = document.getElementById('incoming-call-modal');
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const audioCallBtn = document.getElementById('audio-call-btn');
    const videoCallBtn = document.getElementById('video-call-btn');
    const endCallBtn = document.getElementById('end-call-btn');
    const muteAudioBtn = document.getElementById('mute-audio-btn');
    const muteVideoBtn = document.getElementById('mute-video-btn');
    const answerCallBtn = document.getElementById('answer-call-btn');
    const rejectCallBtn = document.getElementById('reject-call-btn');
    const callIcons = document.getElementById('call-icons');
    const callStatus = document.getElementById('call-status');
    const callTitle = document.getElementById('call-title');
    const minimizeCallBtn = document.getElementById('minimize-call-btn');
    const settingsCallBtn = document.getElementById('settings-call-btn');
    const deviceSettingsModal = document.getElementById('device-settings-modal');
    const microphoneSelect = document.getElementById('microphone-select');
    const cameraSelect = document.getElementById('camera-select');
    const saveSettingsBtn = document.getElementById('save-settings-btn');
    const cancelSettingsBtn = document.getElementById('cancel-settings-btn');
    let isCallMinimized = false;
    let availableDevices = {
        audioInputs: [],
        videoInputs: []
    };
    let selectedDevices = {
        audioInput: null,
        videoInput: null
    };

    // Sidebar toggle functionality
    menuToggle.addEventListener('click', () => {
        sidebar.classList.add('active');
    });
    
    closeSidebarButton.addEventListener('click', () => {
        sidebar.classList.remove('active');
    });

    // Contact search functionality
    contactSearch.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        const allContacts = friendListUl.querySelectorAll('li[data-friend-username], li[data-room-id]');
        
        allContacts.forEach(contact => {
            const name = contact.querySelector('span').textContent.toLowerCase();
            if (name.includes(searchTerm)) {
                contact.style.display = 'flex';
            } else {
                contact.style.display = 'none';
            }
        });
    });

    // Create group functionality
    createGroupBtn.addEventListener('click', () => {
        groupModalTitle.textContent = 'Create New Group';
        createGroupForm.style.display = 'flex';
        editGroupForm.style.display = 'none';
        groupModal.classList.add('active');
        groupNameInput.value = '';
        document.querySelectorAll('#member-selection input[type="checkbox"]').forEach(cb => cb.checked = false);
    });

    cancelGroupBtn.addEventListener('click', () => {
        groupModal.classList.remove('active');
    });

    cancelEditGroupBtn.addEventListener('click', () => {
        groupModal.classList.remove('active');
    });

    createGroupSubmit.addEventListener('click', async () => {
        const groupName = groupNameInput.value.trim();
        const selectedMembers = Array.from(document.querySelectorAll('#member-selection input[type="checkbox"]:checked'))
            .map(cb => cb.value);
        
        if (!groupName) {
            showOverlay('Please enter a group name');
            return;
        }
        
        if (selectedMembers.length < 2) {
            showOverlay('Please select at least 2 members');
            return;
        }
        
        try {
            const response = await fetch('/create_group', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: groupName,
                    members: selectedMembers
                })
            });
            
            const data = await response.json();
            
            if (data.error) {
                showOverlay(data.error);
            } else {
                groupModal.classList.remove('active');
                const groupLi = document.createElement('li');
                groupLi.setAttribute('data-room-id', data.group_id);
                groupLi.setAttribute('data-room-type', 'group');
                groupLi.setAttribute('data-room-name', data.group_name);
                groupLi.innerHTML = `
                    <div class="friend-avatar" style="background: var(--primary);">
                        <i class="fas fa-users"></i>
                    </div>
                    <span>${data.group_name} <span class="group-indicator">GROUP</span></span>
                `;
                friendListUl.insertBefore(groupLi, friendListUl.firstChild);
                showOverlay('Group created successfully!');
            }
        } catch (error) {
            console.error('Error creating group:', error);
            showOverlay('Failed to create group');
        }
    });

    // Edit group functionality
    editGroupBtn.addEventListener('click', async () => {
        if (!currentRoom || !currentRoom.startsWith('group_')) return;
        
        try {
            const response = await fetch(`/get_group_info/${currentRoom}`);
            const data = await response.json();
            
            if (data.error) {
                showOverlay(data.error);
                return;
            }
            
            currentGroupInfo = data;
            groupModalTitle.textContent = 'Edit Group';
            createGroupForm.style.display = 'none';
            editGroupForm.style.display = 'flex';
            editGroupNameInput.value = data.name;
            editGroupNameInput.disabled = !data.is_creator;
            
            // Show members
            groupMembersList.innerHTML = '';
            data.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.classList.add('group-member-item');
                
                const memberInfo = document.createElement('div');
                memberInfo.classList.add('member-info');
                
                const avatar = document.createElement('div');
                avatar.classList.add('member-avatar');
                if (member.profile_picture) {
                    const img = document.createElement('img');
                    img.src = member.profile_picture;
                    avatar.appendChild(img);
                } else {
                    avatar.textContent = member.username[0].toUpperCase();
                }
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = member.username;
                if (member.username === data.creator) {
                    const badge = document.createElement('span');
                    badge.classList.add('creator-badge');
                    badge.textContent = 'CREATOR';
                    nameSpan.appendChild(badge);
                }
                
                memberInfo.appendChild(avatar);
                memberInfo.appendChild(nameSpan);
                memberDiv.appendChild(memberInfo);
                
                // Add kick button for creator
                if (data.is_creator && member.username !== data.creator) {
                    const kickBtn = document.createElement('button');
                    kickBtn.classList.add('kick-btn');
                    kickBtn.innerHTML = '<i class="fas fa-user-times"></i> Kick';
                    kickBtn.onclick = () => kickMember(member.username);
                    memberDiv.appendChild(kickBtn);
                }
                
                groupMembersList.appendChild(memberDiv);
            });
            
            // Show/hide leave button
            leaveGroupBtn.style.display = data.is_creator ? 'none' : 'block';
            
            groupModal.classList.add('active');
        } catch (error) {
            console.error('Error loading group info:', error);
            showOverlay('Failed to load group info');
        }
    });

    async function kickMember(memberUsername) {
        if (!confirm(`Are you sure you want to kick ${memberUsername} from the group?`)) {
            return;
        }
        
        try {
            const response = await fetch(`/update_group/${currentRoom}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'kick',
                    member: memberUsername
                })
            });
            
            const data = await response.json();
            
            if (data.error) {
                showOverlay(data.error);
            } else {
                showOverlay(`${memberUsername} has been kicked from the group`);
                groupModal.classList.remove('active');
                socket.emit('user_kicked_from_group', {
                    room: currentRoom,
                    kicked_user: memberUsername
                });
            }
        } catch (error) {
            console.error('Error kicking member:', error);
            showOverlay('Failed to kick member');
        }
    }

    saveGroupBtn.addEventListener('click', async () => {
        if (!currentGroupInfo || !currentGroupInfo.is_creator) return;
        
        const newName = editGroupNameInput.value.trim();
        if (!newName) {
            showOverlay('Group name cannot be empty');
            return;
        }
        
        try {
            const response = await fetch(`/update_group/${currentRoom}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'rename',
                    name: newName
                })
            });
            
            const data = await response.json();
            
            if (data.error) {
                showOverlay(data.error);
            } else {
                currentChatHeader.textContent = newName;
                const groupLi = friendListUl.querySelector(`li[data-room-id="${currentRoom}"]`);
                if (groupLi) {
                    groupLi.setAttribute('data-room-name', newName);
                    groupLi.querySelector('span').innerHTML = `${newName} <span class="group-indicator">GROUP</span>`;
                }
                groupModal.classList.remove('active');
                showOverlay('Group renamed successfully');
                socket.emit('group_renamed', {
                    room: currentRoom,
                    new_name: newName
                });
            }
        } catch (error) {
            console.error('Error renaming group:', error);
            showOverlay('Failed to rename group');
        }
    });

    leaveGroupBtn.addEventListener('click', async () => {
        if (!confirm('Are you sure you want to leave this group?')) {
            return;
        }
        
        try {
            const response = await fetch(`/update_group/${currentRoom}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'leave'
                })
            });
            
            const data = await response.json();
            
            if (data.error) {
                showOverlay(data.error);
            } else {
                const groupLi = friendListUl.querySelector(`li[data-room-id="${currentRoom}"]`);
                if (groupLi) {
                    groupLi.remove();
                }
                
                groupModal.classList.remove('active');
                currentRoom = null;
                chatMessagesDiv.innerHTML = '';
                currentChatHeader.textContent = '';
                editGroupBtn.style.display = 'none';
                callIcons.style.display = 'none';
                showOverlay('You have left the group');
            }
        } catch (error) {
            console.error('Error leaving group:', error);
            showOverlay('Failed to leave group');
        }
    });

    // Friend/Group click handler
    friendListUl.addEventListener('click', (event) => {
        let targetLi = event.target.closest('li');
        if (targetLi && (targetLi.dataset.friendUsername || targetLi.dataset.roomId)) {
            if (targetLi.dataset.roomType === 'group') {
                const groupId = targetLi.dataset.roomId;
                const groupName = targetLi.dataset.roomName;
                localStorage.setItem('activeRoom', groupId);
                localStorage.setItem('activeRoomType', 'group');
                if (window.innerWidth < 768) {
                    sidebar.classList.remove('active');
                }
                selectRoom(groupId, 'group', groupName, targetLi);
            } else {
                const friendUsername = targetLi.dataset.friendUsername;
                localStorage.setItem('activeFriend', friendUsername);
                localStorage.setItem('activeRoomType', 'direct');
                if (window.innerWidth < 768) {
                    sidebar.classList.remove('active');
                }
                selectFriend(friendUsername, targetLi);
            }
        }
    });

    function selectRoom(roomId, roomType, roomName, targetLi = null) {
        currentRoomType = roomType;
        const newRoomName = roomId;
        
        if (currentRoom === newRoomName) return;
        
        if (currentRoom) {
            socket.emit('leave', { room: currentRoom });
        }
        
        currentRoom = newRoomName;
        messageOffset = 0;
        hasMoreMessages = true;
        
        socket.emit('join', { room: currentRoom });
        loadChatHistory(currentRoom);
        
        Array.from(friendListUl.children).forEach(li => li.classList.remove('active'));
        if (targetLi) {
            targetLi.classList.add('active');
        }
        
        if (selectChatPrompt) {
            selectChatPrompt.style.display = 'none';
        }
        
        if (roomType === 'group') {
            editGroupBtn.style.display = 'inline';
            callIcons.style.display = 'flex';
        } else {
            editGroupBtn.style.display = 'none';
            callIcons.style.display = 'flex';
        }
        
        cancelReply();
    }

    function selectFriend(friendUsername, targetLi = null) {
        currentRoomType = 'direct';
        const newRoomName = [username, friendUsername].sort().join('-');
        
        if (currentRoom === newRoomName) return;
        
        if (currentRoom) {
            socket.emit('leave', { room: currentRoom });
        }
        
        currentRoom = newRoomName;
        messageOffset = 0;
        hasMoreMessages = true;
        
        socket.emit('join', { room: currentRoom });
        loadChatHistory(currentRoom);
        
        Array.from(friendListUl.children).forEach(li => li.classList.remove('active'));
        if (targetLi) {
            targetLi.classList.add('active');
        } else {
            const matchingLi = friendListUl.querySelector(`li[data-friend-username="${friendUsername}"]`);
            if (matchingLi) matchingLi.classList.add('active');
        }
        
        if (selectChatPrompt) {
            selectChatPrompt.style.display = 'none';
        }
        
        callIcons.style.display = 'flex';
        editGroupBtn.style.display = 'none';
        cancelReply();
    }

    function showOverlay(message) {
        overlayMessage.textContent = message;
        statusOverlay.classList.add('active');
    }

    function hideOverlay() {
        statusOverlay.classList.remove('active');
    }

    function scrollToBottom() {
        setTimeout(() => {
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
        }, 100);
    }

    function stripHtmlForPreview(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        return div.textContent || div.innerText || '';
    }

    function scrollToMessage(messageId) {
        const messageElement = chatMessagesDiv.querySelector(`[data-message-id="${messageId}"]`);
        if (messageElement) {
            messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            messageElement.classList.add('highlighted');
            setTimeout(() => {
                messageElement.classList.remove('highlighted');
            }, 1000);
        }
    }

    function addMessage(msg, prepend = false) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message');
        messageDiv.setAttribute('data-message-id', msg.id);
        if (msg.username === username) {
            messageDiv.classList.add('sent');
        } else {
            messageDiv.classList.add('received');
        }

        const avatarDiv = document.createElement('div');
        avatarDiv.classList.add('message-avatar');
        
        if (userProfiles[msg.username] && userProfiles[msg.username].profile_picture) {
            const img = document.createElement('img');
            img.src = userProfiles[msg.username].profile_picture;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.borderRadius = '50%';
            img.style.objectFit = 'cover';
            avatarDiv.appendChild(img);
        } else {
            avatarDiv.textContent = msg.username[0].toUpperCase();
        }

        const contentDiv = document.createElement('div');
        contentDiv.classList.add('message-content');

        if (currentRoomType === 'group' || msg.username !== username) {
            const senderSpan = document.createElement('div');
            senderSpan.classList.add('message-sender');
            senderSpan.textContent = msg.username;
            contentDiv.appendChild(senderSpan);
        }

        if (msg.reply_to) {
            const replyContext = document.createElement('div');
            replyContext.classList.add('message-reply-context');
            replyContext.onclick = () => scrollToMessage(msg.reply_to.id);
            
            const replyUserDiv = document.createElement('div');
            replyUserDiv.classList.add('message-reply-username');
            replyUserDiv.textContent = msg.reply_to.username;
            
            const replyTextDiv = document.createElement('div');
            replyTextDiv.classList.add('message-reply-text');
            replyTextDiv.textContent = stripHtmlForPreview(msg.reply_to.msg);
            
            replyContext.appendChild(replyUserDiv);
            replyContext.appendChild(replyTextDiv);
            contentDiv.appendChild(replyContext);
        }

        const textSpan = document.createElement('span');
        textSpan.innerHTML = msg.msg;

        const timeSpan = document.createElement('div');
        timeSpan.classList.add('message-time');
        timeSpan.textContent = msg.time;

        contentDiv.appendChild(textSpan);
        contentDiv.appendChild(timeSpan);

        messageDiv.appendChild(avatarDiv);
        messageDiv.appendChild(contentDiv);

        if (msg.username === username && !msg.msg.includes("<em>deleted message</em>")) {
            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('message-actions');

            const replyButton = document.createElement('button');
            replyButton.textContent = 'Reply';
            replyButton.classList.add('reply-btn');
            replyButton.onclick = () => startReply(msg.id, msg.username, msg.msg);

            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.onclick = () => startEditMessage(msg.id, msg.msg);

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.onclick = () => deleteMessage(msg.id);

            actionsDiv.appendChild(replyButton);
            actionsDiv.appendChild(editButton);
            actionsDiv.appendChild(deleteButton);
            messageDiv.appendChild(actionsDiv);
        } else if (msg.username !== username && !msg.msg.includes("<em>deleted message</em>")) {
            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('message-actions');

            const replyButton = document.createElement('button');
            replyButton.textContent = 'Reply';
            replyButton.classList.add('reply-btn');
            replyButton.onclick = () => startReply(msg.id, msg.username, msg.msg);

            actionsDiv.appendChild(replyButton);
            messageDiv.appendChild(actionsDiv);
        }

        if (prepend) {
            const firstMsg = chatMessagesDiv.querySelector('.message');
            if (firstMsg) {
                chatMessagesDiv.insertBefore(messageDiv, firstMsg);
            } else {
                chatMessagesDiv.appendChild(messageDiv);
            }
        } else {
            chatMessagesDiv.appendChild(messageDiv);
        }
    }

    function startReply(messageId, messageUsername, messageText) {
        replyingTo = {
            id: messageId,
            username: messageUsername,
            msg: messageText
        };
        
        replyUsername.textContent = messageUsername;
        replyText.textContent = stripHtmlForPreview(messageText);
        replyPreview.style.display = 'flex';
        messageInput.focus();
    }

    function cancelReply() {
        replyingTo = null;
        replyPreview.style.display = 'none';
    }

    cancelReplyBtn.addEventListener('click', cancelReply);

    function updateMessage(messageId, newText) {
        const messageElement = chatMessagesDiv.querySelector(`[data-message-id="${messageId}"]`);
        if (messageElement) {
            const textSpan = messageElement.querySelector('.message-content span');
            if (textSpan) {
                textSpan.innerHTML = newText;
                const actionsDiv = messageElement.querySelector('.message-actions');
                if (actionsDiv) {
                    if (newText.includes("<em>deleted message</em>")) {
                        actionsDiv.style.display = 'none';
                    } else {
                        if (messageElement.classList.contains('sent')) {
                            actionsDiv.style.display = '';
                        }
                    }
                }
            }
        }
    }

    chatMessagesDiv.addEventListener('scroll', async () => {
        if (chatMessagesDiv.scrollTop === 0 && hasMoreMessages && !isLoadingMore) {
            await loadMoreMessages();
        }
    });

    async function loadMoreMessages() {
        if (!currentRoom || isLoadingMore || !hasMoreMessages) return;
        
        isLoadingMore = true;
        const loadingDiv = document.createElement('div');
        loadingDiv.classList.add('loading-messages');
        loadingDiv.textContent = 'Loading more messages...';
        chatMessagesDiv.insertBefore(loadingDiv, chatMessagesDiv.firstChild);
        
        const scrollHeightBefore = chatMessagesDiv.scrollHeight;
        
        try {
            const response = await fetch(`/history/${currentRoom}?offset=${messageOffset}&limit=50`);
            const data = await response.json();
            
            if (data.error) {
                showOverlay(data.error);
                loadingDiv.remove();
                isLoadingMore = false;
                return;
            }
            
            loadingDiv.remove();
            
            if (data.messages && data.messages.length > 0) {
                const usersInMessages = [...new Set(data.messages.map(msg => msg.username))];
                await loadUserProfiles(usersInMessages);
                
                data.messages.forEach(msg => addMessage(msg, true));
                messageOffset += data.messages.length;
                hasMoreMessages = data.has_more;
                
                const scrollHeightAfter = chatMessagesDiv.scrollHeight;
                chatMessagesDiv.scrollTop = scrollHeightAfter - scrollHeightBefore;
            } else {
                hasMoreMessages = false;
            }
        } catch (error) {
            console.error("Error loading more messages:", error);
            loadingDiv.remove();
        } finally {
            isLoadingMore = false;
        }
    }

    async function loadChatHistory(roomName) {
        if (isLoadingHistory || currentRoom !== roomName) return;
        isLoadingHistory = true;
        chatMessagesDiv.innerHTML = '';
        messageOffset = 0;
        hasMoreMessages = true;
        
        if (roomName.startsWith('group_')) {
            const groupLi = friendListUl.querySelector(`li[data-room-id="${roomName}"]`);
            if (groupLi) {
                currentChatHeader.textContent = groupLi.dataset.roomName;
            }
        } else {
            currentChatHeader.textContent = `${roomName.replace(username + '-', '').replace('-' + username, '')}`;
        }
        
        try {
            const response = await fetch(`/history/${roomName}?offset=0&limit=50`);
            const data = await response.json();
            
            if (data.error) {
                showOverlay(data.error);
                currentRoom = null;
                currentChatHeader.textContent = "Error loading chat.";
                callIcons.style.display = 'none';
                editGroupBtn.style.display = 'none';
                return;
            }
            
            const usersInChat = [...new Set(data.messages.map(msg => msg.username))];
            await loadUserProfiles(usersInChat);
            
            data.messages.forEach(msg => addMessage(msg));
            messageOffset = data.messages.length;
            hasMoreMessages = data.has_more;
            scrollToBottom();
        } catch (error) {
            console.error("Error loading chat history:", error);
            showOverlay("Failed to load chat history. Please try again.");
            currentRoom = null;
            currentChatHeader.textContent = "Error loading chat.";
            callIcons.style.display = 'none';
            editGroupBtn.style.display = 'none';
        } finally {
            isLoadingHistory = false;
        }
    }

    async function loadUserProfiles(usernames) {
        try {
            const response = await fetch('/get_user_profiles', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ usernames })
            });
            
            const profiles = await response.json();
            userProfiles = { ...userProfiles, ...profiles };
            
            usernames.forEach(uname => {
                const avatarContainer = document.getElementById(`avatar-${uname}`);
                if (avatarContainer && profiles[uname] && profiles[uname].profile_picture) {
                    avatarContainer.innerHTML = `<img src="${profiles[uname].profile_picture}" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">`;
                }
            });
        } catch (error) {
            console.error('Error loading user profiles:', error);
        }
    }

    sendButton.addEventListener('click', () => {
        const messageText = messageInput.value.trim();
        if (messageText && currentRoom) {
            const messageData = {
                username: username,
                room: currentRoom,
                msg: messageText
            };
            
            if (replyingTo) {
                messageData.reply_to = replyingTo;
            }
            
            socket.emit('send_message', messageData);
            messageInput.value = '';
            messageInput.focus();
            cancelReply();
            setTimeout(scrollToBottom, 50);
            socket.emit('typing_stop', { room: currentRoom });
        } else if (!currentRoom) {
            showOverlay("Please select a friend or group to chat with first.");
        }
    });

    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendButton.click();
        }
    });

    messageInput.addEventListener('input', () => {
        if (currentRoom) {
            socket.emit('typing_start', { room: currentRoom });
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                socket.emit('typing_stop', { room: currentRoom });
            }, 1000);
        }
    });

    messageInput.addEventListener('paste', async (e) => {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1 || items[i].type.indexOf('video') !== -1) {
                e.preventDefault();
                const blob = items[i].getAsFile();
                showMediaPreview(blob);
                break;
            }
        }
    });

    document.addEventListener('paste', async (e) => {
        if (document.activeElement !== messageInput) return;
        
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1 || items[i].type.indexOf('video') !== -1) {
                e.preventDefault();
                const blob = items[i].getAsFile();
                showMediaPreview(blob);
                break;
            }
        }
    });

    function showMediaPreview(file) {
        if (!currentRoom) {
            showOverlay("Please select a friend or group to chat with first.");
            return;
        }
        
        pendingMediaFile = file;
        mediaPreviewContainer.innerHTML = '';
        
        const fileExtension = file.name ? file.name.split('.').pop().toLowerCase() : file.type.split('/')[1];
        const isVideo = file.type.startsWith('video/') || ['mp4', 'webm', 'ogg'].includes(fileExtension);
        
        if (isVideo) {
            const video = document.createElement('video');
            video.controls = true;
            video.src = URL.createObjectURL(file);
            mediaPreviewContainer.appendChild(video);
        } else {
            const img = document.createElement('img');
            img.src = URL.createObjectURL(file);
            mediaPreviewContainer.appendChild(img);
        }
        
        mediaPreviewModal.classList.add('active');
    }

    sendMediaBtn.addEventListener('click', async () => {
        if (!pendingMediaFile) return;
        
        mediaPreviewModal.classList.remove('active');
        
        const formData = new FormData();
        formData.append('file', pendingMediaFile);
        
        try {
            const response = await fetch('/upload_file', {
                method: 'POST',
                body: formData
            });
            const data = await response.json();
            
            if (data.error) {
                showOverlay(`File upload failed: ${data.error}`);
            } else if (data.url) {
                const fileName = pendingMediaFile.name || 'file';
                const fileExtension = fileName.split('.').pop().toLowerCase();
                let messageContent;
                
                if (['png', 'jpg', 'jpeg', 'gif'].includes(fileExtension)) {
                    messageContent = `<a href="${data.url}" target="_blank"><img src="${data.url}" class="message-file image" alt="Uploaded Image"></a>`;
                } else if (['mp4', 'webm', 'ogg'].includes(fileExtension)) {
                    messageContent = `<video controls src="${data.url}" class="message-file video"></video>`;
                } else {
                    messageContent = `<a href="${data.url}" target="_blank">Uploaded file: ${fileName}</a>`;
                }
                
                const messageData = {
                    username: username,
                    room: currentRoom,
                    msg: messageContent
                };
                
                if (replyingTo) {
                    messageData.reply_to = replyingTo;
                }
                
                socket.emit('send_message', messageData);
                messageInput.focus();
                cancelReply();
            }
        } catch (error) {
            console.error("Error uploading file:", error);
            showOverlay("An error occurred during file upload.");
        } finally {
            pendingMediaFile = null;
        }
    });

    cancelMediaBtn.addEventListener('click', () => {
        mediaPreviewModal.classList.remove('active');
        pendingMediaFile = null;
        mediaPreviewContainer.innerHTML = '';
    });

    fileInput.addEventListener('change', async (event) => {
        if (!currentRoom) {
            showOverlay("Please select a friend or group to chat with first.");
            fileInput.value = '';
            return;
        }
        const file = event.target.files[0];
        if (!file) return;
        
        showMediaPreview(file);
        fileInput.value = '';
    });

    function startEditMessage(messageId, currentMessageText) {
        const messageElement = chatMessagesDiv.querySelector(`[data-message-id="${messageId}"]`);
        if (!messageElement) return;
        const textSpan = messageElement.querySelector('.message-content span');
        if (!textSpan) return;
        const existingInput = messageElement.querySelector('.message-edit-input');
        if (existingInput) {
            existingInput.remove();
        }
        const cleanText = currentMessageText.replace(/<em>\(edited\)<\/em>/, '').trim();
        const input = document.createElement('input');
        input.type = 'text';
        input.value = cleanText;
        input.classList.add('message-edit-input');
        input.onkeypress = (e) => {
            if (e.key === 'Enter') {
                confirmEditMessage(messageId, input.value, input);
                e.preventDefault();
            }
        };
        input.onblur = () => {
            confirmEditMessage(messageId, input.value, input, true);
        };
        const actionsDiv = messageElement.querySelector('.message-actions');
        if (actionsDiv) actionsDiv.style.display = 'none';
        textSpan.replaceWith(input);
        input.focus();
        input.select();
    }

    function confirmEditMessage(messageId, newText, inputElement, onBlur = false) {
        const originalText = inputElement.defaultValue;
        const messageElement = chatMessagesDiv.querySelector(`[data-message-id="${messageId}"]`);
        const textSpan = document.createElement('span');
        if (newText.trim() === '' && !onBlur) {
            showOverlay("Message cannot be empty.");
            textSpan.innerHTML = originalText;
            inputElement.replaceWith(textSpan);
            const actionsDiv = messageElement.querySelector('.message-actions');
            if (actionsDiv) actionsDiv.style.display = '';
            return;
        } else if (newText.trim() === '' || newText === originalText) {
            textSpan.innerHTML = originalText;
            inputElement.replaceWith(textSpan);
            const actionsDiv = messageElement.querySelector('.message-actions');
            if (actionsDiv) actionsDiv.style.display = '';
            return;
        }
        socket.emit('edit_message', {
            message_id: messageId,
            new_text: newText,
            room: currentRoom
        });
        textSpan.innerHTML = newText + ' <em>(edited)</em>';
        inputElement.replaceWith(textSpan);
        const actionsDiv = messageElement.querySelector('.message-actions');
        if (actionsDiv) actionsDiv.style.display = '';
    }

    function deleteMessage(messageId) {
        if (confirm("Are you sure you want to delete this message?")) {
            socket.emit('delete_message', {
                message_id: messageId,
                room: currentRoom
            });
        }
    }

    // WebRTC Functions
    async function loadAvailableDevices() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            availableDevices.audioInputs = devices.filter(device => device.kind === 'audioinput');
            availableDevices.videoInputs = devices.filter(device => device.kind === 'videoinput');
            microphoneSelect.innerHTML = '';
            availableDevices.audioInputs.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `Microphone ${index + 1}`;
                microphoneSelect.appendChild(option);
            });
            cameraSelect.innerHTML = '';
            availableDevices.videoInputs.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `Camera ${index + 1}`;
                cameraSelect.appendChild(option);
            });
            if (selectedDevices.audioInput) {
                microphoneSelect.value = selectedDevices.audioInput;
            }
            if (selectedDevices.videoInput) {
                cameraSelect.value = selectedDevices.videoInput;
            }
        } catch (error) {
            console.error('Error loading devices:', error);
        }
    }

    async function switchMediaDevice(deviceType, deviceId) {
        if (!localStream) return;
        try {
            const constraints = {};
            if (deviceType === 'audio') {
                constraints.audio = { deviceId: { exact: deviceId } };
                const oldAudioTrack = localStream.getAudioTracks()[0];
                if (oldAudioTrack) {
                    oldAudioTrack.stop();
                    localStream.removeTrack(oldAudioTrack);
                }
                const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                const newAudioTrack = newStream.getAudioTracks()[0];
                localStream.addTrack(newAudioTrack);
                if (peerConnection) {
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'audio');
                    if (sender) {
                        await sender.replaceTrack(newAudioTrack);
                    }
                }
                selectedDevices.audioInput = deviceId;
            } else if (deviceType === 'video') {
                constraints.video = { deviceId: { exact: deviceId } };
                const oldVideoTrack = localStream.getVideoTracks()[0];
                if (oldVideoTrack) {
                    oldVideoTrack.stop();
                    localStream.removeTrack(oldVideoTrack);
                }
                const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                const newVideoTrack = newStream.getVideoTracks()[0];
                localStream.addTrack(newVideoTrack);
                localVideo.srcObject = localStream;
                if (peerConnection) {
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        await sender.replaceTrack(newVideoTrack);
                    }
                }
                selectedDevices.videoInput = deviceId;
            }
        } catch (error) {
            console.error('Error switching device:', error);
            showOverlay('Failed to switch device. Please try again.');
        }
    }

    function addSystemMessage(message, icon = 'phone') {
        const systemDiv = document.createElement('div');
        systemDiv.classList.add('system-message');
        systemDiv.innerHTML = `<i class="fas fa-${icon}"></i>${message}`;
        chatMessagesDiv.appendChild(systemDiv);
        scrollToBottom();
    }

    function logCallToChat(callType, action, otherUser) {
        let message = '';
        const icon = callType === 'video' ? 'video' : 'phone';
        if (action === 'started') {
            message = `${callType === 'video' ? 'Video' : 'Audio'} call started with ${otherUser}`;
        } else if (action === 'ended') {
            message = `${callType === 'video' ? 'Video' : 'Audio'} call ended`;
        } else if (action === 'missed') {
            message = `Missed ${callType === 'video' ? 'video' : 'audio'} call from ${otherUser}`;
        }
        addSystemMessage(message, icon);
    }

    async function startCall(callType) {
        if (!currentRoom) {
            showOverlay("Please select a friend or group to call.");
            return;
        }
        
        let receiver;
        if (currentRoomType === 'group') {
            receiver = currentRoom;
        } else {
            receiver = currentRoom.replace(username + '-', '').replace('-' + username, '');
        }
        
        try {
            currentCallType = callType;
            const constraints = {
                audio: selectedDevices.audioInput 
                    ? { deviceId: { exact: selectedDevices.audioInput } }
                    : true,
                video: callType === 'video' 
                    ? (selectedDevices.videoInput 
                        ? { deviceId: { exact: selectedDevices.videoInput } }
                        : true)
                    : false
            };
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            await loadAvailableDevices();
            localVideo.srcObject = localStream;
            callModal.classList.add('active');
            callStatus.textContent = 'Calling...';
            callTitle.textContent = callType === 'video' ? 'Video Call' : 'Audio Call';
            if (callType === 'audio') {
                localVideo.style.display = 'none';
                muteVideoBtn.style.display = 'none';
            }
            socket.emit('call_user', {
                receiver: receiver,
                type: callType,
                room: currentRoom
            });
            isCallActive = true;
        } catch (error) {
            console.error('Error starting call:', error);
            showOverlay('Failed to access camera/microphone. Please check permissions.');
            closeCall();
        }
    }

    async function answerCall() {
        if (!incomingCallData) return;
        try {
            currentCallType = incomingCallData.type;
            const constraints = {
                audio: selectedDevices.audioInput 
                    ? { deviceId: { exact: selectedDevices.audioInput } }
                    : true,
                video: incomingCallData.type === 'video'
                    ? (selectedDevices.videoInput 
                        ? { deviceId: { exact: selectedDevices.videoInput } }
                        : true)
                    : false
            };
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            await loadAvailableDevices();
            localVideo.srcObject = localStream;
            incomingCallModal.classList.remove('active');
            callModal.classList.add('active');
            callStatus.textContent = 'Connected';
            callTitle.textContent = incomingCallData.type === 'video' ? 'Video Call' : 'Audio Call';
            if (incomingCallData.type === 'audio') {
                localVideo.style.display = 'none';
                muteVideoBtn.style.display = 'none';
            }
            socket.emit('answer_call', {
                caller: incomingCallData.caller,
                room: incomingCallData.room,
                type: incomingCallData.type
            });
            await createPeerConnection();
            isCallActive = true;
            logCallToChat(incomingCallData.type, 'started', incomingCallData.caller);
        } catch (error) {
            console.error('Error answering call:', error);
            showOverlay('Failed to access camera/microphone.');
            rejectCall();
        }
    }

    function rejectCall() {
        if (!incomingCallData) return;
        socket.emit('reject_call', {
            caller: incomingCallData.caller,
            room: incomingCallData.room
        });
        incomingCallModal.classList.remove('active');
        logCallToChat(incomingCallData.type, 'missed', incomingCallData.caller);
        incomingCallData = null;
    }

    function closeCall() {
        const wasActive = isCallActive;
        const callType = currentCallType;
        const otherUser = currentRoom ? currentRoom.replace(username + '-', '').replace('-' + username, '') : '';
        if (isCallActive && currentRoom) {
            socket.emit('end_call', { room: currentRoom });
        }
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        callModal.classList.remove('active');
        callModal.classList.remove('minimized');
        incomingCallModal.classList.remove('active');
        localVideo.style.display = 'block';
        muteVideoBtn.style.display = 'block';
        isCallMinimized = false;
        if (wasActive && callType && otherUser) {
            logCallToChat(callType, 'ended', otherUser);
        }
        isCallActive = false;
        currentCallType = null;
        incomingCallData = null;
    }

    async function createPeerConnection() {
        peerConnection = new RTCPeerConnection(configuration);
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });
        peerConnection.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
                callStatus.textContent = 'Connected';
            }
        };
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('webrtc_ice_candidate', {
                    room: currentRoom,
                    candidate: event.candidate
                });
            }
        };
        peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', peerConnection.connectionState);
            if (peerConnection.connectionState === 'connected') {
                callStatus.textContent = 'Connected';
            } else if (peerConnection.connectionState === 'disconnected' || 
                       peerConnection.connectionState === 'failed') {
                closeCall();
            }
        };
    }

    function toggleMuteAudio() {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                muteAudioBtn.classList.toggle('active');
                const icon = muteAudioBtn.querySelector('i');
                icon.className = audioTrack.enabled ? 'fas fa-microphone' : 'fas fa-microphone-slash';
            }
        }
    }

    function toggleMuteVideo() {
        if (localStream) {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                muteVideoBtn.classList.toggle('active');
                const icon = muteVideoBtn.querySelector('i');
                icon.className = videoTrack.enabled ? 'fas fa-video' : 'fas fa-video-slash';
            }
        }
    }

    function toggleMinimizeCall() {
        isCallMinimized = !isCallMinimized;
        callModal.classList.toggle('minimized');
        const icon = minimizeCallBtn.querySelector('i');
        if (isCallMinimized) {
            icon.className = 'fas fa-expand';
            minimizeCallBtn.title = 'Maximize';
        } else {
            icon.className = 'fas fa-minus';
            minimizeCallBtn.title = 'Minimize';
        }
    }

    function openDeviceSettings() {
        loadAvailableDevices();
        deviceSettingsModal.classList.add('active');
    }

    function closeDeviceSettings() {
        deviceSettingsModal.classList.remove('active');
    }

    async function saveDeviceSettings() {
        const selectedMic = microphoneSelect.value;
        const selectedCam = cameraSelect.value;
        if (isCallActive && localStream) {
            if (selectedMic && selectedMic !== selectedDevices.audioInput) {
                await switchMediaDevice('audio', selectedMic);
            }
            if (selectedCam && selectedCam !== selectedDevices.videoInput && currentCallType === 'video') {
                await switchMediaDevice('video', selectedCam);
            }
        } else {
            selectedDevices.audioInput = selectedMic;
            selectedDevices.videoInput = selectedCam;
        }
        closeDeviceSettings();
    }

    audioCallBtn.addEventListener('click', () => startCall('audio'));
    videoCallBtn.addEventListener('click', () => startCall('video'));
    endCallBtn.addEventListener('click', closeCall);
    muteAudioBtn.addEventListener('click', toggleMuteAudio);
    muteVideoBtn.addEventListener('click', toggleMuteVideo);
    answerCallBtn.addEventListener('click', answerCall);
    rejectCallBtn.addEventListener('click', rejectCall);
    minimizeCallBtn.addEventListener('click', toggleMinimizeCall);
    settingsCallBtn.addEventListener('click', openDeviceSettings);
    saveSettingsBtn.addEventListener('click', saveDeviceSettings);
    cancelSettingsBtn.addEventListener('click', closeDeviceSettings);
    callModal.addEventListener('click', (e) => {
        if (isCallMinimized && e.target === callModal) {
            toggleMinimizeCall();
        }
    });

    // Socket.IO Events
    socket.on('connect', () => {
        console.log('Connected to Socket.IO');
        socket.emit('user_connected');
        userStatus = 'online';
        socket.emit('request_statuses');
        
        const friendUsernames = Array.from(friendListUl.querySelectorAll('li[data-friend-username]'))
            .map(li => li.dataset.friendUsername);
        if (friendUsernames.length > 0) {
            loadUserProfiles(friendUsernames);
        }
        
        const storedRoomType = localStorage.getItem('activeRoomType');
        if (storedRoomType === 'group') {
            const storedRoom = localStorage.getItem('activeRoom');
            if (storedRoom) {
                const groupLi = friendListUl.querySelector(`li[data-room-id="${storedRoom}"]`);
                if (groupLi) {
                    selectRoom(storedRoom, 'group', groupLi.dataset.roomName, groupLi);
                }
            }
        } else {
            const storedFriend = localStorage.getItem('activeFriend');
            if (storedFriend) {
                selectFriend(storedFriend);
            }
        }
    });

    socket.on('message', (data) => {
        if (data.room === currentRoom) {
            if (!userProfiles[data.username]) {
                loadUserProfiles([data.username]);
            }
            addMessage(data);
            scrollToBottom();
        }
    });

    socket.on('message_updated', (data) => {
        if (data.room === currentRoom) {
            const newTextWithEditedTag = data.new_text.includes("<em>(edited)</em>")
                                        ? data.new_text
                                        : `${data.new_text} <em>(edited)</em>`;
            updateMessage(data.id, newTextWithEditedTag);
            scrollToBottom();
        }
    });

    socket.on('error', (data) => {
        console.error('Socket Error:', data.message);
        showOverlay(data.message);
        if (data.message.includes('not friends') || data.message.includes('blocked') || 
            data.message.includes('Unauthorized') || data.message.includes('not a member')) {
            currentRoom = null;
            chatMessagesDiv.innerHTML = '';
            currentChatHeader.textContent = "";
            callIcons.style.display = 'none';
            editGroupBtn.style.display = 'none';
            if (selectChatPrompt) {
                selectChatPrompt.style.display = 'block';
                selectChatPrompt.textContent = "Select a friend or group from the sidebar to start chatting.";
            }
        }
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from Socket.IO');
        socket.emit('user_disconnected');
        showOverlay("Disconnected from chat server. Please refresh or check your internet connection.");
    });

    socket.on('user_status_update', (data) => {
        const statusIndicator = document.querySelector(`.status-indicator[data-username="${data.username}"]`);
        if (statusIndicator) {
            statusIndicator.className = 'status-indicator';
            statusIndicator.classList.add(data.status);
        }
        connectedUsers[data.username] = data.status;
    });

    socket.on('user_typing', (data) => {
        const typingIndicator = document.getElementById('typing-indicator');
        if (data.is_typing) {
            if (!typingIndicator) {
                const indicator = document.createElement('div');
                indicator.id = 'typing-indicator';
                indicator.className = 'typing-indicator';
                indicator.innerHTML = `
                    <span>${data.username}</span>
                    <span>is typing</span>
                    <span>...</span>
                `;
                chatMessagesDiv.appendChild(indicator);
                scrollToBottom();
            }
        } else {
            const existingIndicator = document.getElementById('typing-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }
    });

    socket.on('all_statuses', (data) => {
        Object.keys(data).forEach(username => {
            const statusIndicator = document.querySelector(`.status-indicator[data-username="${username}"]`);
            if (statusIndicator) {
                statusIndicator.className = 'status-indicator';
                statusIndicator.classList.add(data[username].status);
            }
        });
    });

    socket.on('incoming_call', (data) => {
        incomingCallData = data;
        document.getElementById('caller-name').textContent = `${data.caller} is calling...`;
        document.getElementById('call-type-text').textContent = data.type === 'video' ? 'Video Call' : 'Audio Call';
        incomingCallModal.classList.add('active');
    });

    socket.on('call_answered', async (data) => {
        callStatus.textContent = 'Connecting...';
        await createPeerConnection();
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('webrtc_offer', {
            room: currentRoom,
            offer: offer
        });
        const otherUser = currentRoom.replace(username + '-', '').replace('-' + username, '');
        logCallToChat(currentCallType, 'started', otherUser);
    });

    socket.on('call_rejected', (data) => {
        showOverlay(`${data.rejecter} rejected your call.`);
        closeCall();
    });

    socket.on('call_ended', (data) => {
        showOverlay('Call ended.');
        closeCall();
    });

    socket.on('webrtc_offer', async (data) => {
        if (!peerConnection) {
            await createPeerConnection();
        }
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit('webrtc_answer', {
            room: currentRoom,
            answer: answer
        });
    });

    socket.on('webrtc_answer', async (data) => {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
    });

    socket.on('webrtc_ice_candidate', async (data) => {
        if (peerConnection && data.candidate) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
    });

    // Mobile keyboard handling
    const chatArea = document.querySelector('.chat-area');
    let isAboutToSend = false;
    function handleMobileFocus() {
        if (window.innerWidth > 768) return;
        chatArea.style.paddingBottom = '20vh';
        setTimeout(() => {
            messageInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 150);
    }
    function handleMobileBlur() {
        if (window.innerWidth <= 768) {
            setTimeout(() => {
                if (!isAboutToSend) {
                    chatArea.style.paddingBottom = '0';
                }
                isAboutToSend = false;
            }, 300);
        }
    }
    sendButton.addEventListener('mousedown', () => isAboutToSend = true);
    sendButton.addEventListener('touchstart', () => isAboutToSend = true);
    messageInput.addEventListener('focus', handleMobileFocus);
    messageInput.addEventListener('blur', handleMobileBlur);

    navigator.mediaDevices.getUserMedia({ audio: true, video: true })
        .then(stream => {
            stream.getTracks().forEach(track => track.stop());
            loadAvailableDevices();
        })
        .catch(err => {
            console.log('Media permission not granted yet:', err);
        });
</script>
{% endblock %}
