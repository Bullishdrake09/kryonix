{% extends "base.html" %}

{% block title %}Kryonix Chat - {{ username }}{% endblock %}

{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

<style>
/* Reply UI Styles */
.reply-preview {
    background: rgba(138, 43, 226, 0.15);
    border-left: 3px solid #8a2be2;
    padding: 8px 12px;
    margin: 8px 0;
    border-radius: 12px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(138, 43, 226, 0.3);
}

.reply-preview-content {
    flex: 1;
}

.reply-preview-username {
    color: #8a2be2;
    font-size: 0.85em;
    font-weight: 700;
    margin-bottom: 2px;
    text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
}

.reply-preview-text {
    color: #adb5bd;
    font-size: 0.9em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 90%;
}

.reply-preview-close {
    background: none;
    border: none;
    color: #6c757d;
    cursor: pointer;
    font-size: 1.2em;
    padding: 0;
    margin-left: 8px;
    transition: all 0.3s ease;
}

.reply-preview-close:hover {
    color: #ff6b6b;
    transform: scale(1.1);
}

.message-reply-context {
    background: rgba(138, 43, 226, 0.1);
    border-left: 3px solid #8a2be2;
    padding: 6px 10px;
    margin-bottom: 6px;
    border-radius: 8px;
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid rgba(138, 43, 226, 0.2);
}

.message-reply-context:hover {
    background: rgba(138, 43, 226, 0.2);
    transform: translateX(3px);
    border-color: rgba(138, 43, 226, 0.4);
}

.message-reply-username {
    color: #8a2be2;
    font-weight: 700;
    margin-bottom: 2px;
    text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
}

.message-reply-text {
    color: #adb5bd;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.message.highlighted {
    animation: highlight-pulse 1s ease-in-out;
}

@keyframes highlight-pulse {
    0%, 100% {
        background: transparent;
    }
    50% {
        background: rgba(138, 43, 226, 0.3);
        box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
    }
}

.message-actions button.reply-btn {
    background: linear-gradient(45deg, rgba(138, 43, 226, 0.2), rgba(75, 0, 130, 0.2));
    color: #8a2be2;
    border: 1px solid rgba(138, 43, 226, 0.3);
    transition: all 0.3s ease;
}

.message-actions button.reply-btn:hover {
    background: linear-gradient(45deg, #8a2be2, #4b0082);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
}
</style>

<div class="mobile-header" id="mobile-header">
    <button class="menu-toggle" id="menu-toggle"><i class="fas fa-bars"></i></button>
    <h2 id="mobile-chat-title">Kryonix Chat</h2>
    <span style="visibility: hidden;"><i class="fas fa-bars"></i></span>
</div>

<div class="app-container">
    <div class="sidebar" id="sidebar">
        <button class="close-button" id="close-sidebar-button"><i class="fas fa-times"></i></button>
        <div class="user-info">
            <div class="avatar">{{ current_user.username[0].upper() }}</div>
            <div class="username">{{ username }}</div>
        </div>
        <nav>
            <a href="{{ url_for('chat') }}">Chats</a>
            <a href="{{ url_for('friends') }}">Friends</a>
            <a href="{{ url_for('settings') }}">Settings</a>
            {% if current_user.username == 'admin' %}
            <a href="{{ url_for('admin_page') }}">Admin Panel</a>
            {% endif %}
        </nav>

        <div class="friends-list">
            <h3>Friends</h3>
            <ul id="friend-list-ul">
                {% if not friends_list %}
                <p class="initial-chat-message">Select a friend to start chatting</p>
                {% endif %}
                {% for friend in friends_list %}
                <li data-friend-username="{{ friend }}">
                    <div class="friend-avatar">{{ friend[0].upper() }}
                        <span class="status-indicator online" data-username="{{ friend }}"></span>
                    </div>
                    <span>{{ friend }}</span>
                </li>
                {% else %}
                <li>No friends yet. Add some in the <a href="{{ url_for('friends') }}">Friends page</a>!</li>
                {% endfor %}
            </ul>
        </div>
        <a href="{{ url_for('logout') }}" class="logout-button">Logout</a>
    </div>

    <div class="chat-area">
        <div id="status-overlay">
            <p id="overlay-message"></p>
            <button onclick="hideOverlay()">OK</button>
        </div>

        <div class="chat-header">
            <h2 id="current-chat-header"></h2>
            <div class="header-links">
                <div class="call-icons" id="call-icons" style="display: none;">
                    <button class="call-icon-btn" id="audio-call-btn" title="Audio Call">
                        <i class="fas fa-phone"></i>
                    </button>
                    <button class="call-icon-btn" id="video-call-btn" title="Video Call">
                        <i class="fas fa-video"></i>
                    </button>
                </div>
                <a href="{{ url_for('friends') }}">Manage Friends</a>
            </div>
        </div>
        
        <!-- Reply Preview Bar -->
        <div class="reply-preview" id="reply-preview" style="display: none;">
            <div class="reply-preview-content">
                <div class="reply-preview-username" id="reply-username"></div>
                <div class="reply-preview-text" id="reply-text"></div>
            </div>
            <button class="reply-preview-close" id="cancel-reply">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="chat-messages" id="chat-messages">
            {% if not friends_list %}
            <p class="initial-chat-message">Add friends to start chatting!</p>
            {% else %}
            <p class="initial-chat-message" id="select-chat-prompt">Select a friend from the sidebar to start chatting.</p>
            {% endif %}
        </div>
        
        <div class="chat-input-area">
            <input type="text" id="message-input" placeholder="Type a message...">
            <label for="file-input">
                <i class="fas fa-paperclip"></i>
            </label>
            <input type="file" id="file-input" accept="image/*,video/*">
            <button id="send-button"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>
</div>

<!-- Video Call Modal -->
<div class="call-modal" id="call-modal">
    <div class="call-content">
        <div class="call-header">
            <h3 id="call-title">Video Call</h3>
            <span id="call-status" style="color: var(--gray);">Connecting...</span>
        </div>
        <button class="settings-call-btn" id="settings-call-btn" title="Settings">
            <i class="fas fa-cog"></i>
        </button>
        <button class="minimize-call-btn" id="minimize-call-btn" title="Minimize">
            <i class="fas fa-minus"></i>
        </button>
        <div class="video-container">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>
        </div>
        <div class="call-controls">
            <button class="call-button mute" id="mute-audio-btn" title="Mute Audio">
                <i class="fas fa-microphone"></i>
            </button>
            <button class="call-button mute" id="mute-video-btn" title="Turn Off Video">
                <i class="fas fa-video"></i>
            </button>
            <button class="call-button end" id="end-call-btn" title="End Call">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>
</div>

<!-- Device Settings Modal -->
<div class="device-settings-modal" id="device-settings-modal">
    <h3><i class="fas fa-cog"></i> Device Settings</h3>
    <div class="device-setting">
        <label for="microphone-select">Microphone</label>
        <select id="microphone-select">
            <option value="">Loading...</option>
        </select>
    </div>
    <div class="device-setting">
        <label for="camera-select">Camera</label>
        <select id="camera-select">
            <option value="">Loading...</option>
        </select>
    </div>
    <div class="device-settings-actions">
        <button class="save-settings-btn" id="save-settings-btn">Apply</button>
        <button class="cancel-settings-btn" id="cancel-settings-btn">Cancel</button>
    </div>
</div>

<!-- Incoming Call Modal -->
<div class="incoming-call-modal" id="incoming-call-modal">
    <h3><i class="fas fa-phone" style="color: var(--primary);"></i> Incoming Call</h3>
    <p id="caller-name">Someone is calling you...</p>
    <p id="call-type-text">Video Call</p>
    <div class="incoming-call-actions">
        <button class="answer-button" id="answer-call-btn">
            <i class="fas fa-phone"></i> Answer
        </button>
        <button class="reject-button" id="reject-call-btn">
            <i class="fas fa-phone-slash"></i> Reject
        </button>
    </div>
</div>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
    const socket = io();
    const username = "{{ username }}";
    let currentRoom = null;
    let isLoadingHistory = false;
    let userStatus = 'offline';
    let typingTimeout = null;
    let connectedUsers = {};
    let replyingTo = null; // Track message being replied to
    
    // WebRTC variables
    let localStream = null;
    let remoteStream = null;
    let peerConnection = null;
    let currentCallType = null;
    let isCallActive = false;
    let incomingCallData = null;
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };
    const sidebar = document.getElementById('sidebar');
    const menuToggle = document.getElementById('menu-toggle');
    const closeSidebarButton = document.getElementById('close-sidebar-button');
    const chatMessagesDiv = document.getElementById('chat-messages');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const currentChatHeader = document.getElementById('current-chat-header');
    const friendListUl = document.getElementById('friend-list-ul');
    const fileInput = document.getElementById('file-input');
    const statusOverlay = document.getElementById('status-overlay');
    const overlayMessage = document.getElementById('overlay-message');
    const selectChatPrompt = document.getElementById('select-chat-prompt');
    
    // Reply elements
    const replyPreview = document.getElementById('reply-preview');
    const replyUsername = document.getElementById('reply-username');
    const replyText = document.getElementById('reply-text');
    const cancelReplyBtn = document.getElementById('cancel-reply');
    
    // Call elements
    const callModal = document.getElementById('call-modal');
    const incomingCallModal = document.getElementById('incoming-call-modal');
    const localVideo = document.getElementById('local-video');
    const remoteVideo = document.getElementById('remote-video');
    const audioCallBtn = document.getElementById('audio-call-btn');
    const videoCallBtn = document.getElementById('video-call-btn');
    const endCallBtn = document.getElementById('end-call-btn');
    const muteAudioBtn = document.getElementById('mute-audio-btn');
    const muteVideoBtn = document.getElementById('mute-video-btn');
    const answerCallBtn = document.getElementById('answer-call-btn');
    const rejectCallBtn = document.getElementById('reject-call-btn');
    const callIcons = document.getElementById('call-icons');
    const callStatus = document.getElementById('call-status');
    const callTitle = document.getElementById('call-title');
    const minimizeCallBtn = document.getElementById('minimize-call-btn');
    const settingsCallBtn = document.getElementById('settings-call-btn');
    const deviceSettingsModal = document.getElementById('device-settings-modal');
    const microphoneSelect = document.getElementById('microphone-select');
    const cameraSelect = document.getElementById('camera-select');
    const saveSettingsBtn = document.getElementById('save-settings-btn');
    const cancelSettingsBtn = document.getElementById('cancel-settings-btn');
    let isCallMinimized = false;
    let availableDevices = {
        audioInputs: [],
        videoInputs: []
    };
    let selectedDevices = {
        audioInput: null,
        videoInput: null
    };

    // Sidebar toggle functionality
    menuToggle.addEventListener('click', () => {
        sidebar.classList.add('active');
    });
    closeSidebarButton.addEventListener('click', () => {
        sidebar.classList.remove('active');
    });

    // Friend click handler
    friendListUl.addEventListener('click', (event) => {
        let targetLi = event.target.closest('li');
        if (targetLi && targetLi.dataset.friendUsername) {
            const friendUsername = targetLi.dataset.friendUsername;
            localStorage.setItem('activeFriend', friendUsername);
            if (window.innerWidth < 768) {
                sidebar.classList.remove('active');
            }
            selectFriend(friendUsername, targetLi);
        }
    });

    function selectFriend(friendUsername, targetLi = null) {
        const newRoomName = [username, friendUsername].sort().join('-');
        if (currentRoom === newRoomName) return;
        if (currentRoom) {
            socket.emit('leave', { room: currentRoom });
        }
        currentRoom = newRoomName;
        socket.emit('join', { room: currentRoom });
        loadChatHistory(currentRoom);
        Array.from(friendListUl.children).forEach(li => li.classList.remove('active'));
        if (targetLi) {
            targetLi.classList.add('active');
        } else {
            const matchingLi = friendListUl.querySelector(`li[data-friend-username="${friendUsername}"]`);
            if (matchingLi) matchingLi.classList.add('active');
        }
        if (selectChatPrompt) {
            selectChatPrompt.style.display = 'none';
        }
        callIcons.style.display = 'flex';
        cancelReply(); // Clear any active reply
    }

    function showOverlay(message) {
        overlayMessage.textContent = message;
        statusOverlay.classList.add('active');
    }

    function hideOverlay() {
        statusOverlay.classList.remove('active');
    }

    function scrollToBottom() {
        setTimeout(() => {
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
        }, 100);
    }

    function stripHtmlForPreview(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        return div.textContent || div.innerText || '';
    }

    function scrollToMessage(messageId) {
        const messageElement = chatMessagesDiv.querySelector(`[data-message-id="${messageId}"]`);
        if (messageElement) {
            messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            messageElement.classList.add('highlighted');
            setTimeout(() => {
                messageElement.classList.remove('highlighted');
            }, 1000);
        }
    }

    function addMessage(msg) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message');
        messageDiv.setAttribute('data-message-id', msg.id);
        if (msg.username === username) {
            messageDiv.classList.add('sent');
        } else {
            messageDiv.classList.add('received');
        }

        const avatarDiv = document.createElement('div');
        avatarDiv.classList.add('message-avatar');
        avatarDiv.textContent = msg.username[0].toUpperCase();

        const contentDiv = document.createElement('div');
        contentDiv.classList.add('message-content');

        const senderSpan = document.createElement('div');
        senderSpan.classList.add('message-sender');
        senderSpan.textContent = msg.username;

        // Add reply context if present
        if (msg.reply_to) {
            const replyContext = document.createElement('div');
            replyContext.classList.add('message-reply-context');
            replyContext.onclick = () => scrollToMessage(msg.reply_to.id);
            
            const replyUserDiv = document.createElement('div');
            replyUserDiv.classList.add('message-reply-username');
            replyUserDiv.textContent = msg.reply_to.username;
            
            const replyTextDiv = document.createElement('div');
            replyTextDiv.classList.add('message-reply-text');
            replyTextDiv.textContent = stripHtmlForPreview(msg.reply_to.msg);
            
            replyContext.appendChild(replyUserDiv);
            replyContext.appendChild(replyTextDiv);
            contentDiv.appendChild(replyContext);
        }

        const textSpan = document.createElement('span');
        textSpan.innerHTML = msg.msg;

        const timeSpan = document.createElement('div');
        timeSpan.classList.add('message-time');
        timeSpan.textContent = msg.time;

        if (msg.username !== username) {
            contentDiv.appendChild(senderSpan);
        }
        contentDiv.appendChild(textSpan);
        contentDiv.appendChild(timeSpan);

        messageDiv.appendChild(avatarDiv);
        messageDiv.appendChild(contentDiv);

        if (msg.username === username && !msg.msg.includes("<em>deleted message</em>")) {
            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('message-actions');

            const replyButton = document.createElement('button');
            replyButton.textContent = 'Reply';
            replyButton.classList.add('reply-btn');
            replyButton.onclick = () => startReply(msg.id, msg.username, msg.msg);

            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.onclick = () => startEditMessage(msg.id, msg.msg);

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.onclick = () => deleteMessage(msg.id);

            actionsDiv.appendChild(replyButton);
            actionsDiv.appendChild(editButton);
            actionsDiv.appendChild(deleteButton);
            messageDiv.appendChild(actionsDiv);
        } else if (msg.username !== username && !msg.msg.includes("<em>deleted message</em>")) {
            // Add reply button for received messages
            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('message-actions');

            const replyButton = document.createElement('button');
            replyButton.textContent = 'Reply';
            replyButton.classList.add('reply-btn');
            replyButton.onclick = () => startReply(msg.id, msg.username, msg.msg);

            actionsDiv.appendChild(replyButton);
            messageDiv.appendChild(actionsDiv);
        }

        chatMessagesDiv.appendChild(messageDiv);
    }

    function startReply(messageId, messageUsername, messageText) {
        replyingTo = {
            id: messageId,
            username: messageUsername,
            msg: messageText
        };
        
        replyUsername.textContent = messageUsername;
        replyText.textContent = stripHtmlForPreview(messageText);
        replyPreview.style.display = 'flex';
        messageInput.focus();
    }

    function cancelReply() {
        replyingTo = null;
        replyPreview.style.display = 'none';
    }

    cancelReplyBtn.addEventListener('click', cancelReply);

    function updateMessage(messageId, newText) {
        const messageElement = chatMessagesDiv.querySelector(`[data-message-id="${messageId}"]`);
        if (messageElement) {
            const textSpan = messageElement.querySelector('.message-content span');
            if (textSpan) {
                textSpan.innerHTML = newText;
                const actionsDiv = messageElement.querySelector('.message-actions');
                if (actionsDiv) {
                    if (newText.includes("<em>deleted message</em>")) {
                        actionsDiv.style.display = 'none';
                    } else {
                        if (messageElement.classList.contains('sent')) {
                            actionsDiv.style.display = '';
                        }
                    }
                }
            }
        }
    }

    async function loadChatHistory(roomName) {
        if (isLoadingHistory || currentRoom !== roomName) return;
        isLoadingHistory = true;
        chatMessagesDiv.innerHTML = '';
        currentChatHeader.textContent = `${roomName.replace(username + '-', '').replace('-' + username, '')}`;
        try {
            const response = await fetch(`/history/${roomName}`);
            const data = await response.json();
            if (data.error) {
                showOverlay(data.error);
                currentRoom = null;
                currentChatHeader.textContent = "Error loading chat.";
                callIcons.style.display = 'none';
                return;
            }
            data.messages.forEach(msg => addMessage(msg));
            scrollToBottom();
        } catch (error) {
            console.error("Error loading chat history:", error);
            showOverlay("Failed to load chat history. Please try again.");
            currentRoom = null;
            currentChatHeader.textContent = "Error loading chat.";
            callIcons.style.display = 'none';
        } finally {
            isLoadingHistory = false;
        }
    }

    sendButton.addEventListener('click', () => {
        const messageText = messageInput.value.trim();
        if (messageText && currentRoom) {
            const messageData = {
                username: username,
                room: currentRoom,
                msg: messageText
            };
            
            // Add reply data if replying
            if (replyingTo) {
                messageData.reply_to = replyingTo;
            }
            
            socket.emit('send_message', messageData);
            messageInput.value = '';
            messageInput.focus();
            cancelReply();
            setTimeout(scrollToBottom, 50);
            socket.emit('typing_stop', { room: currentRoom });
        } else if (!currentRoom) {
            showOverlay("Please select a friend to chat with first.");
        }
    });

    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendButton.click();
        }
    });

    messageInput.addEventListener('input', () => {
        if (currentRoom) {
            socket.emit('typing_start', { room: currentRoom });
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                socket.emit('typing_stop', { room: currentRoom });
            }, 1000);
        }
    });

    fileInput.addEventListener('change', async (event) => {
        if (!currentRoom) {
            showOverlay("Please select a friend to chat with first.");
            fileInput.value = '';
            return;
        }
        const file = event.target.files[0];
        if (!file) return;
        const formData = new FormData();
        formData.append('file', file);
        try {
            const response = await fetch('/upload_file', {
                method: 'POST',
                body: formData
            });
            const data = await response.json();
            if (data.error) {
                showOverlay(`File upload failed: ${data.error}`);
            } else if (data.url) {
                const fileExtension = file.name.split('.').pop().toLowerCase();
                let messageContent;
                if (['png', 'jpg', 'jpeg', 'gif'].includes(fileExtension)) {
                    messageContent = `<a href="${data.url}" target="_blank"><img src="${data.url}" class="message-file image" alt="Uploaded Image"></a>`;
                } else if (['mp4', 'webm', 'ogg'].includes(fileExtension)) {
                    messageContent = `<video controls src="${data.url}" class="message-file video"></video>`;
                } else {
                    messageContent = `<a href="${data.url}" target="_blank">Uploaded file: ${file.name}</a>`;
                }
                
                const messageData = {
                    username: username,
                    room: currentRoom,
                    msg: messageContent
                };
                
                // Add reply data if replying
                if (replyingTo) {
                    messageData.reply_to = replyingTo;
                }
                
                socket.emit('send_message', messageData);
                messageInput.focus();
                cancelReply();
            }
        } catch (error) {
            console.error("Error uploading file:", error);
            showOverlay("An error occurred during file upload.");
        } finally {
            fileInput.value = '';
        }
    });

    function startEditMessage(messageId, currentMessageText) {
        const messageElement = chatMessagesDiv.querySelector(`[data-message-id="${messageId}"]`);
        if (!messageElement) return;
        const textSpan = messageElement.querySelector('.message-content span');
        if (!textSpan) return;
        const existingInput = messageElement.querySelector('.message-edit-input');
        if (existingInput) {
            existingInput.remove();
        }
        const cleanText = currentMessageText.replace(/<em>\(edited\)<\/em>/, '').trim();
        const input = document.createElement('input');
        input.type = 'text';
        input.value = cleanText;
        input.classList.add('message-edit-input');
        input.onkeypress = (e) => {
            if (e.key === 'Enter') {
                confirmEditMessage(messageId, input.value, input);
                e.preventDefault();
            }
        };
        input.onblur = () => {
            confirmEditMessage(messageId, input.value, input, true);
        };
        const actionsDiv = messageElement.querySelector('.message-actions');
        if (actionsDiv) actionsDiv.style.display = 'none';
        textSpan.replaceWith(input);
        input.focus();
        input.select();
    }

    function confirmEditMessage(messageId, newText, inputElement, onBlur = false) {
        const originalText = inputElement.defaultValue;
        const messageElement = chatMessagesDiv.querySelector(`[data-message-id="${messageId}"]`);
        const textSpan = document.createElement('span');
        if (newText.trim() === '' && !onBlur) {
            showOverlay("Message cannot be empty.");
            textSpan.innerHTML = originalText;
            inputElement.replaceWith(textSpan);
            const actionsDiv = messageElement.querySelector('.message-actions');
            if (actionsDiv) actionsDiv.style.display = '';
            return;
        } else if (newText.trim() === '' || newText === originalText) {
            textSpan.innerHTML = originalText;
            inputElement.replaceWith(textSpan);
            const actionsDiv = messageElement.querySelector('.message-actions');
            if (actionsDiv) actionsDiv.style.display = '';
            return;
        }
        socket.emit('edit_message', {
            message_id: messageId,
            new_text: newText,
            room: currentRoom
        });
        textSpan.innerHTML = newText + ' <em>(edited)</em>';
        inputElement.replaceWith(textSpan);
        const actionsDiv = messageElement.querySelector('.message-actions');
        if (actionsDiv) actionsDiv.style.display = '';
    }

    function deleteMessage(messageId) {
        if (confirm("Are you sure you want to delete this message?")) {
            socket.emit('delete_message', {
                message_id: messageId,
                room: currentRoom
            });
        }
    }

    // ===== VIDEO CALL FUNCTIONS =====
    async function loadAvailableDevices() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            availableDevices.audioInputs = devices.filter(device => device.kind === 'audioinput');
            availableDevices.videoInputs = devices.filter(device => device.kind === 'videoinput');
            microphoneSelect.innerHTML = '';
            availableDevices.audioInputs.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `Microphone ${index + 1}`;
                microphoneSelect.appendChild(option);
            });
            cameraSelect.innerHTML = '';
            availableDevices.videoInputs.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `Camera ${index + 1}`;
                cameraSelect.appendChild(option);
            });
            if (selectedDevices.audioInput) {
                microphoneSelect.value = selectedDevices.audioInput;
            }
            if (selectedDevices.videoInput) {
                cameraSelect.value = selectedDevices.videoInput;
            }
        } catch (error) {
            console.error('Error loading devices:', error);
        }
    }

    async function switchMediaDevice(deviceType, deviceId) {
        if (!localStream) return;
        try {
            const constraints = {};
            if (deviceType === 'audio') {
                constraints.audio = { deviceId: { exact: deviceId } };
                const oldAudioTrack = localStream.getAudioTracks()[0];
                if (oldAudioTrack) {
                    oldAudioTrack.stop();
                    localStream.removeTrack(oldAudioTrack);
                }
                const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                const newAudioTrack = newStream.getAudioTracks()[0];
                localStream.addTrack(newAudioTrack);
                if (peerConnection) {
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'audio');
                    if (sender) {
                        await sender.replaceTrack(newAudioTrack);
                    }
                }
                selectedDevices.audioInput = deviceId;
            } else if (deviceType === 'video') {
                constraints.video = { deviceId: { exact: deviceId } };
                const oldVideoTrack = localStream.getVideoTracks()[0];
                if (oldVideoTrack) {
                    oldVideoTrack.stop();
                    localStream.removeTrack(oldVideoTrack);
                }
                const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                const newVideoTrack = newStream.getVideoTracks()[0];
                localStream.addTrack(newVideoTrack);
                localVideo.srcObject = localStream;
                if (peerConnection) {
                    const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        await sender.replaceTrack(newVideoTrack);
                    }
                }
                selectedDevices.videoInput = deviceId;
            }
        } catch (error) {
            console.error('Error switching device:', error);
            showOverlay('Failed to switch device. Please try again.');
        }
    }

    function addSystemMessage(message, icon = 'phone') {
        const systemDiv = document.createElement('div');
        systemDiv.classList.add('system-message');
        systemDiv.innerHTML = `<i class="fas fa-${icon}"></i>${message}`;
        chatMessagesDiv.appendChild(systemDiv);
        scrollToBottom();
    }

    function logCallToChat(callType, action, otherUser) {
        let message = '';
        const icon = callType === 'video' ? 'video' : 'phone';
        if (action === 'started') {
            message = `${callType === 'video' ? 'Video' : 'Audio'} call started with ${otherUser}`;
        } else if (action === 'ended') {
            message = `${callType === 'video' ? 'Video' : 'Audio'} call ended`;
        } else if (action === 'missed') {
            message = `Missed ${callType === 'video' ? 'video' : 'audio'} call from ${otherUser}`;
        }
        addSystemMessage(message, icon);
        const messageId = `system_${Date.now()}`;
        const timestamp = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        socket.emit('send_message', {
            username: 'System',
            room: currentRoom,
            msg: `<em>${message}</em>`
        });
    }

    async function startCall(callType) {
        if (!currentRoom) {
            showOverlay("Please select a friend to call.");
            return;
        }
        const receiver = currentRoom.replace(username + '-', '').replace('-' + username, '');
        try {
            currentCallType = callType;
            const constraints = {
                audio: selectedDevices.audioInput 
                    ? { deviceId: { exact: selectedDevices.audioInput } }
                    : true,
                video: callType === 'video' 
                    ? (selectedDevices.videoInput 
                        ? { deviceId: { exact: selectedDevices.videoInput } }
                        : true)
                    : false
            };
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            await loadAvailableDevices();
            localVideo.srcObject = localStream;
            callModal.classList.add('active');
            callStatus.textContent = 'Calling...';
            callTitle.textContent = callType === 'video' ? 'Video Call' : 'Audio Call';
            if (callType === 'audio') {
                localVideo.style.display = 'none';
                muteVideoBtn.style.display = 'none';
            }
            socket.emit('call_user', {
                receiver: receiver,
                type: callType,
                room: currentRoom
            });
            isCallActive = true;
        } catch (error) {
            console.error('Error starting call:', error);
            showOverlay('Failed to access camera/microphone. Please check permissions.');
            closeCall();
        }
    }

    async function answerCall() {
        if (!incomingCallData) return;
        try {
            currentCallType = incomingCallData.type;
            const constraints = {
                audio: selectedDevices.audioInput 
                    ? { deviceId: { exact: selectedDevices.audioInput } }
                    : true,
                video: incomingCallData.type === 'video'
                    ? (selectedDevices.videoInput 
                        ? { deviceId: { exact: selectedDevices.videoInput } }
                        : true)
                    : false
            };
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            await loadAvailableDevices();
            localVideo.srcObject = localStream;
            incomingCallModal.classList.remove('active');
            callModal.classList.add('active');
            callStatus.textContent = 'Connected';
            callTitle.textContent = incomingCallData.type === 'video' ? 'Video Call' : 'Audio Call';
            if (incomingCallData.type === 'audio') {
                localVideo.style.display = 'none';
                muteVideoBtn.style.display = 'none';
            }
            socket.emit('answer_call', {
                caller: incomingCallData.caller,
                room: incomingCallData.room,
                type: incomingCallData.type
            });
            await createPeerConnection();
            isCallActive = true;
            logCallToChat(incomingCallData.type, 'started', incomingCallData.caller);
        } catch (error) {
            console.error('Error answering call:', error);
            showOverlay('Failed to access camera/microphone.');
            rejectCall();
        }
    }

    function rejectCall() {
        if (!incomingCallData) return;
        socket.emit('reject_call', {
            caller: incomingCallData.caller,
            room: incomingCallData.room
        });
        incomingCallModal.classList.remove('active');
        logCallToChat(incomingCallData.type, 'missed', incomingCallData.caller);
        incomingCallData = null;
    }

    function closeCall() {
        const wasActive = isCallActive;
        const callType = currentCallType;
        const otherUser = currentRoom ? currentRoom.replace(username + '-', '').replace('-' + username, '') : '';
        if (isCallActive && currentRoom) {
            socket.emit('end_call', { room: currentRoom });
        }
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        callModal.classList.remove('active');
        callModal.classList.remove('minimized');
        incomingCallModal.classList.remove('active');
        localVideo.style.display = 'block';
        muteVideoBtn.style.display = 'block';
        isCallMinimized = false;
        if (wasActive && callType && otherUser) {
            logCallToChat(callType, 'ended', otherUser);
        }
        isCallActive = false;
        currentCallType = null;
        incomingCallData = null;
    }

    async function createPeerConnection() {
        peerConnection = new RTCPeerConnection(configuration);
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });
        peerConnection.ontrack = (event) => {
            if (event.streams && event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
                callStatus.textContent = 'Connected';
            }
        };
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                socket.emit('webrtc_ice_candidate', {
                    room: currentRoom,
                    candidate: event.candidate
                });
            }
        };
        peerConnection.onconnectionstatechange = () => {
            console.log('Connection state:', peerConnection.connectionState);
            if (peerConnection.connectionState === 'connected') {
                callStatus.textContent = 'Connected';
            } else if (peerConnection.connectionState === 'disconnected' || 
                       peerConnection.connectionState === 'failed') {
                closeCall();
            }
        };
    }

    function toggleMuteAudio() {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                muteAudioBtn.classList.toggle('active');
                const icon = muteAudioBtn.querySelector('i');
                icon.className = audioTrack.enabled ? 'fas fa-microphone' : 'fas fa-microphone-slash';
            }
        }
    }

    function toggleMuteVideo() {
        if (localStream) {
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                muteVideoBtn.classList.toggle('active');
                const icon = muteVideoBtn.querySelector('i');
                icon.className = videoTrack.enabled ? 'fas fa-video' : 'fas fa-video-slash';
            }
        }
    }

    function toggleMinimizeCall() {
        isCallMinimized = !isCallMinimized;
        callModal.classList.toggle('minimized');
        const icon = minimizeCallBtn.querySelector('i');
        if (isCallMinimized) {
            icon.className = 'fas fa-expand';
            minimizeCallBtn.title = 'Maximize';
        } else {
            icon.className = 'fas fa-minus';
            minimizeCallBtn.title = 'Minimize';
        }
    }

    function openDeviceSettings() {
        loadAvailableDevices();
        deviceSettingsModal.classList.add('active');
    }

    function closeDeviceSettings() {
        deviceSettingsModal.classList.remove('active');
    }

    async function saveDeviceSettings() {
        const selectedMic = microphoneSelect.value;
        const selectedCam = cameraSelect.value;
        if (isCallActive && localStream) {
            if (selectedMic && selectedMic !== selectedDevices.audioInput) {
                await switchMediaDevice('audio', selectedMic);
            }
            if (selectedCam && selectedCam !== selectedDevices.videoInput && currentCallType === 'video') {
                await switchMediaDevice('video', selectedCam);
            }
        } else {
            selectedDevices.audioInput = selectedMic;
            selectedDevices.videoInput = selectedCam;
        }
        closeDeviceSettings();
    }

    audioCallBtn.addEventListener('click', () => startCall('audio'));
    videoCallBtn.addEventListener('click', () => startCall('video'));
    endCallBtn.addEventListener('click', closeCall);
    muteAudioBtn.addEventListener('click', toggleMuteAudio);
    muteVideoBtn.addEventListener('click', toggleMuteVideo);
    answerCallBtn.addEventListener('click', answerCall);
    rejectCallBtn.addEventListener('click', rejectCall);
    minimizeCallBtn.addEventListener('click', toggleMinimizeCall);
    settingsCallBtn.addEventListener('click', openDeviceSettings);
    saveSettingsBtn.addEventListener('click', saveDeviceSettings);
    cancelSettingsBtn.addEventListener('click', closeDeviceSettings);
    callModal.addEventListener('click', (e) => {
        if (isCallMinimized && e.target === callModal) {
            toggleMinimizeCall();
        }
    });

    // ===== SOCKET EVENTS =====
    socket.on('connect', () => {
        console.log('Connected to Socket.IO');
        socket.emit('user_connected');
        userStatus = 'online';
        socket.emit('request_statuses');
        const storedFriend = localStorage.getItem('activeFriend');
        if (storedFriend) {
            selectFriend(storedFriend);
        } else {
            const firstFriendLi = friendListUl.querySelector('li[data-friend-username]');
            if (firstFriendLi) {
                selectFriend(firstFriendLi.dataset.friendUsername, firstFriendLi);
            } else {
                currentChatHeader.textContent = "";
                if (selectChatPrompt) {
                    selectChatPrompt.style.display = 'block';
                    selectChatPrompt.textContent = "Add friends to start chatting!";
                }
            }
        }
    });

    socket.on('message', (data) => {
        if (data.room === currentRoom) {
            addMessage(data);
            scrollToBottom();
        }
    });

    socket.on('message_updated', (data) => {
        if (data.room === currentRoom) {
            const newTextWithEditedTag = data.new_text.includes("<em>(edited)</em>")
                                        ? data.new_text
                                        : `${data.new_text} <em>(edited)</em>`;
            updateMessage(data.id, newTextWithEditedTag);
            scrollToBottom();
        }
    });

    socket.on('error', (data) => {
        console.error('Socket Error:', data.message);
        showOverlay(data.message);
        if (data.message.includes('not friends') || data.message.includes('blocked') || data.message.includes('Unauthorized')) {
            currentRoom = null;
            chatMessagesDiv.innerHTML = '';
            currentChatHeader.textContent = "";
            callIcons.style.display = 'none';
            if (selectChatPrompt) {
                selectChatPrompt.style.display = 'block';
                selectChatPrompt.textContent = "Select a friend from the sidebar to start chatting.";
            }
        }
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from Socket.IO');
        socket.emit('user_disconnected');
        showOverlay("Disconnected from chat server. Please refresh or check your internet connection.");
    });

    socket.on('user_status_update', (data) => {
        updateFriendStatus(data.username, data.status);
    });

    socket.on('user_typing', (data) => {
        showTypingIndicator(data.username, data.is_typing);
    });

    socket.on('all_statuses', (data) => {
        Object.keys(data).forEach(username => {
            updateFriendStatus(username, data[username].status);
        });
    });

    socket.on('incoming_call', (data) => {
        incomingCallData = data;
        document.getElementById('caller-name').textContent = `${data.caller} is calling...`;
        document.getElementById('call-type-text').textContent = data.type === 'video' ? 'Video Call' : 'Audio Call';
        incomingCallModal.classList.add('active');
    });

    socket.on('call_answered', async (data) => {
        callStatus.textContent = 'Connecting...';
        await createPeerConnection();
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('webrtc_offer', {
            room: currentRoom,
            offer: offer
        });
        const otherUser = currentRoom.replace(username + '-', '').replace('-' + username, '');
        logCallToChat(currentCallType, 'started', otherUser);
    });

    socket.on('call_rejected', (data) => {
        showOverlay(`${data.rejecter} rejected your call.`);
        closeCall();
    });

    socket.on('call_ended', (data) => {
        showOverlay('Call ended.');
        closeCall();
    });

    socket.on('webrtc_offer', async (data) => {
        if (!peerConnection) {
            await createPeerConnection();
        }
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit('webrtc_answer', {
            room: currentRoom,
            answer: answer
        });
    });

    socket.on('webrtc_answer', async (data) => {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
    });

    socket.on('webrtc_ice_candidate', async (data) => {
        if (peerConnection && data.candidate) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
    });

    function updateFriendStatus(username, status) {
        const statusIndicator = document.querySelector(`.status-indicator[data-username="${username}"]`);
        if (statusIndicator) {
            statusIndicator.className = 'status-indicator';
            statusIndicator.classList.add(status);
        }
        connectedUsers[username] = status;
    }

    function showTypingIndicator(username, isTyping) {
        const typingIndicator = document.getElementById('typing-indicator');
        if (isTyping) {
            if (!typingIndicator) {
                const indicator = document.createElement('div');
                indicator.id = 'typing-indicator';
                indicator.className = 'typing-indicator';
                indicator.innerHTML = `
                    <span>${username}</span>
                    <span>is typing</span>
                    <span>...</span>
                `;
                chatMessagesDiv.appendChild(indicator);
                scrollToBottom();
            }
        } else {
            const existingIndicator = document.getElementById('typing-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }
    }

    const chatArea = document.querySelector('.chat-area');
    let isAboutToSend = false;
    function handleMobileFocus() {
        if (window.innerWidth > 768) return;
        chatArea.style.paddingBottom = '20vh';
        setTimeout(() => {
            messageInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 150);
    }
    function handleMobileBlur() {
        if (window.innerWidth <= 768) {
            setTimeout(() => {
                if (!isAboutToSend) {
                    chatArea.style.paddingBottom = '0';
                }
                isAboutToSend = false;
            }, 300);
        }
    }
    sendButton.addEventListener('mousedown', () => isAboutToSend = true);
    sendButton.addEventListener('touchstart', () => isAboutToSend = true);
    messageInput.addEventListener('focus', handleMobileFocus);
    messageInput.addEventListener('blur', handleMobileBlur);

    navigator.mediaDevices.getUserMedia({ audio: true, video: true })
        .then(stream => {
            stream.getTracks().forEach(track => track.stop());
            loadAvailableDevices();
        })
        .catch(err => {
            console.log('Media permission not granted yet:', err);
        });
</script>
{% endblock %}
